---
title: 'Step 1 - Extending VTEX APIs schema'
sidebar_label: 'API Extensions'
---

import { Callout, Step, Steps, FileTree, Tabs, Tab } from 'nextra-theme-docs'
import { ExtendableQueryTable } from './../../../components/ExtendableQueryTable'

<header>

# Extending APIs Schema with FastStore

</header>

## Extending VTEX APIs Schema with FastStore

FastStore streamlines the way of using data from VTEX APIs that the FastStore API does not expose.

As FastStore uses GraphQL, it's required to write [type definitions](https://graphql.org/learn/schema/#object-types-and-fields) and [resolvers](https://graphql.org/learn/execution/#root-fields-resolvers) to fetch the data you need. 
To define new type definitions and resolvers for FastStore using GraphQL, learn how to create a specific directory structure in the following step by step. 

### Step by step
#### Step 1 - Preparing the folders and files 

To declare a new type definition and resolver you need to create a directory structure:

1. In you store repository, go to the `src` folder and create the `graphql` subfolder. You can do this by running the following command in your terminal:

<Tabs items={['macOs and Linux', 'Windows']}>
  <Tab>
  ```bash copy
  mkdir graphql
  ```
  </Tab>

  <Tab>
   ```bash copy
  mkdir graphql
  ```
  </Tab>
</Tabs>

2. Inside the new `graphql` folder, create the `vtex` subfolder.

<Tabs items={['macOs and Linux', 'Windows']}>
  <Tab>
  ```bash copy
  mkdir vtex
  ```
  </Tab>

  <Tab>
   ```bash copy
  mkdir vtex
  ```
  </Tab>
</Tabs>

3. In `vtex`, create `resolvers` and `typeDefs` subfolders.
<Tabs items={['macOs and Linux', 'Windows']}>
  <Tab>
  ```bash copy
  mkdir resolvers/typeDefs
  ```
  </Tab>

  <Tab>
   ```bash copy
  mkdir resolvers\typeDefs
  ```
  </Tab>
</Tabs>

<Callout type="warning" emoji="⚠️">
  The `src/graphql/vtex/resolvers` and `src/graphql/vtex/typeDefs` path is mandatory, but you can organize the files inside those directory as you wish.
</Callout>

4. Create a `index.ts` file inside the `resolvers` folder.

Once you have created the essentials folders, you will have a folder structure for the VTEX API Schema Extensions in the `src/graphql/vtex` folder similiar to the the following:

```ts copy
starter.store/
└─ src/
    └─ graphql/
        └─ vtex/
          ├─ resolvers/
              └─ index.ts
              └─ <resolverName>.ts
              └─ …
          ├─ typeDefs/
              └─<typeName>.graphql
              └─ …
```

Note that the `<resolverName>.ts` and `<typeName>.graphql` were already declared.

#### Step 2 - Creating type definitions (`TypeDefs`)


```
Questions this step should answer:
- In the last callout on this step 2, *Also, the `index.ts` is not needed for typeDefs, only for resolvers.*, why the index file is only important for the resolvers folder.?
- In *2. Declare the following to the `product.graphql*, what can be the purpose of it to mey store?
```

Your new type definitions set the data structure for your new fields, extended from the existing FastStore API GraphQL queries and types.

1. Create a new `<typeName>.graphql` file inside the `vtex/typeDefs` folder. For example, let's extends the [StoreProduct](https://v1.faststore.dev/reference/api/objects#storeproduct) type
from FastStore API, so the name of the file is `product.graphql`.


<Callout type="info" emoji="ℹ️">
  The way that it will be organized inside this folder is flexible, it's possible to create multiple typeDefs files or group them all together in just one file.
  During the build process and when running the local server file, all `.graphql` files under this directory will be considered.
</Callout>

2. Declare the following to the `product.graphql`:

```graphql filename="graphql/vtex/typeDefs/product.graphql"

extend type StoreProduct {
  """
  Custom data extending StoreProduct
  """
  customData: String!
}

```
Once you declare it, it will `Add the purpose of it` in your store.

<Callout type="warning" emoji="⚠️">
  The typeDefs files must have `.graphql` extension.
Also, the `index.ts` is not needed for typeDefs, only for resolvers.

</Callout>

#### Step 3 - Creating resolvers

```
Questions this step should answer:
- In *3 - Import the resolvers inside the index.ts file, spread them in the resolver object and re-export the final resolver object.*, What's the purpose?
- In *That's it! Once you have defined these files in the vtex folder, the new fields are already exposed.*, how can I test it if it's really working?
- In *The entire GraphQL creation process is automated and handled in the background by the FastStore CLI.*, should I run yarn dev here? It seems some steps is missing here.
```

Resolvers are the functions that give meaning to the data you have structured in the type definitions. 
This means a resolver will be executed when the corresponding piece of information is queried. 
These resolver can perform an operation on an existing field, get data from the Root param, or fetch data from VTEX APIs, for example.

1. Create a new `<resolver>.graphql` file inside the `vtex/resolvers` folder. Let's continue the [StoreProduct](https://v1.faststore.dev/reference/api/objects#storeproduct) type
example, so the name of the file is `product.ts`.

<Callout type="info" emoji="ℹ️">
  The way that it will be organized inside this folder is flexible, it's possible to create multiple resolvers files or group them all together in just one file.
</Callout>

2. Declare the following to the `product.ts`:

```ts copy filename="graphql/vtex/resolvers/product.ts"

import type { StoreProductRoot } from '@faststore/api'

const productResolver = {
  StoreProduct: {
    customData: (root: StoreProductRoot) => {
      return 'My item id: ' + root.itemId
    },
  },
}

export default productResolver
```

Note that you can leverage the use of TypeScript by typing the root param as [StoreProductRoot](https://v1.faststore.dev/reference/api/root-object-fields#root-product):

![using-root-field-type](https://vtexhelp.vtexassets.com/assets/docs/src/root-field-ts___3a10ec8a1aeba9770c7ee982995d55bc.gif)

3. Import the resolvers inside the `index.ts` file, spread them in the resolver object and re-export the final resolver object. `(What's the purpose?)`

```ts copy filename="graphql/vtex/resolvers/index.ts"

import { default as StoreProductResolver } from './product'

const resolvers = {
  ...StoreProductResolver,
}

export default resolvers
```

That's it! Once you have defined these files in the `vtex` folder, the new fields are already exposed. 
The entire GraphQL creation process is automated and handled in the background by the [FastStore CLI](/docs/getting-started/4-faststore-cli). 

## Extending third-party APIs schema


```
Questions that this doc should answer:
- If I want to define Third-party and VTEX schema extensions what should be the best in terms of directory structure?
- The directory structure for both looks similiar. Is that the case we present a basic/general directory structure, including `vtex` and `third-party` and then we present what should be
added in those subfolders?
- In the sentence *Intending to separate what comes from VTEX and what comes from third-party APIs*, What is the reason for this separation? Help in the debuging process if needed?
```

As stores tend to grow, so does the possibility of consuming new data that is **not provided by default in the FastStore API or other VTEX APIs**. 
As such, FastStore must consume new data from third-party APIs.

Intending to separate what comes from VTEX and what comes from third-party APIs `(Why? Help in the debuging process if needed?)`, the store's repository provides the following folder structure for third-party APIs Schema Extensions that is held in the `src/graphql/thirdParty` folder:

```ts copy
starter.store/
└── src/
    └── graphql/
        ├── thirdParty/
        │   ├── resolvers/
        │       └── index.ts
        │       └── <resolverName>.ts
        │       └── …
        │   ├── typeDefs/
        │       └── <typeName>.graphql
        │       └── …
```

Following this structure, you can use the same pattern mentioned above regarding the VTEX API Schema extensions but using the `thirdParty` folder, with resolvers and typeDefs inside their respective folders and resolvers being imported into the `index.ts` file.

One crucial aspect to consider when developing a third-party extension is the creation of a Query or Mutation schema. This schema plays a vital role in generating new query entry points to access data.
Below, you will find an example code the implementation of a third-party extension:

```ts copy filename="graphql/thirdParty/typeDefs/extra.graphql"

type ExtraData {
  """
  Data customizing ExtraData
  """
  data: String!
}

type Query {
  extraData: ExtraData
  namedExtraData(name: String!): ExtraData
}
```

```ts copy filename="graphql/thirdParty/resolvers/extra.ts"

const extraDataResolver = {
  Query: {
    extraData: () => {
      return {
        data: 'Extra data',
      }
    },
    namedExtraData: (_, { name }) => {
      return {
        data: `Named extra data: ${name}`,
      }
    },
  },
}

export default extraDataResolver
```

```ts copy filename="graphql/thirdParty/resolvers/index.ts"

import { default as StoreExtraResolver } from './extra'

const resolvers = {
  ...StoreExtraResolver,
}

export default resolvers
```

In this example, the extra data is accessible by this query:

```ts copy
query {
	extraData {
		data
	}
	namedExtraData(name: "Hello") {
		data
	}
}
```
---
title: '   Extending VTEX APIs schema'
sidebar_label: 'API Extensions'
---

import { Callout, Step, Steps, FileTree } from 'nextra-theme-docs'
import { ExtendableQueryTable } from './../../../components/ExtendableQueryTable'

<header>

# Extending VTEX APIs Schema with FastStore

</header>

FastStore streamlines the way of using data from VTEX APIs that the FastStore API does not expose.

As FastStore uses GraphQL, it's required to write [type definitions](https://graphql.org/learn/schema/#object-types-and-fields) and [resolvers](https://graphql.org/learn/execution/#root-fields-resolvers) to fetch the data you need. 
Learn how to do this using API Extensions by following the steps below.

## Step by step
## Step 1 - Understand the folder structure

In the store's repository, you'll find the following folder structure for the VTEX API Schema Extensions in the `src/graphql/vtex` folder:

```ts copy
starter.store/
└─ src/
    └─ graphql/
        └─ vtex/
          ├─ resolvers/
              └─ index.ts
              └─ <resolverName>.ts
              └─ …
          ├─ typeDefs/
              └─<typeName>.graphql
              └─ …
```

## Step 2 - Creating type definitions (`TypeDefs`)

Your new type definitions set the data structure for your new fields, extended from the existing FastStore API GraphQL queries and types.

You can create a new `<typeName>.graphql` files inside the `vtex/typeDefs` folder. The way that it will be organized inside this folder is flexible, it's possible to create multiple typeDefs files or group them all together in just one file.

See the following code example that creates a `product.graphql` file, that extends the [StoreProduct](https://v1.faststore.dev/reference/api/objects#storeproduct) type from FastStore API and exposes a new `customData` field:

```graphql filename="graphql/vtex/typeDefs/product.graphql"

extend type StoreProduct {
  """
  Custom data extending StoreProduct
  """
  customData: String!
}

```

<Callout type="warning" emoji="⚠️">
  The typeDefs files must have `.graphql` extension.
Also, the `index.ts` is not needed for typeDefs, only for resolvers.

</Callout>

### Step 3 - Creating resolvers

Resolvers are the functions that give meaning to the data you have structured in the type definitions. This means a resolver will be executed when the corresponding piece of information is queried. These resolver can perform an operation on an existing field, get data from the Root param, or fetch data from VTEX APIs, for example.

You can create new `<resolverName>.ts` files inside the `vtex>resolvers` folder.

<Callout type="info" emoji="ℹ️">
  The way that it will be organized inside this folder is flexible, it's possible to create multiple resolvers files or group them all together in just one file.
</Callout>

See the following code example that creates a `product.ts` resolver file and resolves the `customData` field from `StoreProduct`:

```ts copy filename="graphql/vtex/resolvers/product.ts"

import type { StoreProductRoot } from '@faststore/api'

const productResolver = {
  StoreProduct: {
    customData: (root: StoreProductRoot) => {
      return 'My item id: ' + root.itemId
    },
  },
}

export default productResolver
```

As you see, you can leverage the use of TypeScript by typing the root param as [StoreProductRoot](https://v1.faststore.dev/reference/api/root-object-fields#root-product):

![using-root-field-type](https://vtexhelp.vtexassets.com/assets/docs/src/root-field-ts___3a10ec8a1aeba9770c7ee982995d55bc.gif)

Then, it's important to import the resolvers inside the `index.ts` file, spread them in the resolver object and re-export the final resolver object.

```ts copy filename="graphql/vtex/resolvers/index.ts"

import { default as StoreProductResolver } from './product'

const resolvers = {
  ...StoreProductResolver,
}

export default resolvers
```

That's it, you only need to define these files within the vtex folder for the sake of exposing the new fields. The entire GraphQL creation process must be transparent and done in the background by the FastStore.

### Step 4 - How to use

**TBD - After the Consume new fields from pages features be done. Here we can be inspired by these steps:**

1. add the `customData` field in the `Fragment X` from the `Y file`.
2. run `yarn dev` in the core package.
3. run `yarn generate` in the core package (with `yarn dev` running).
4. Get and use the `customData` as you want in Z section.

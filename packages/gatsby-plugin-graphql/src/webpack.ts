import { dirname, join } from 'path'

import { codegen } from '@graphql-codegen/core'
import * as typeScriptPlugin from '@graphql-codegen/typescript'
import * as typeScriptOperationsPlugin from '@graphql-codegen/typescript-operations'
import { optimizeDocuments } from '@graphql-tools/relay-operation-optimizer'
import { mkdirSync, outputJson } from 'fs-extra'
import { GraphQLSchema, parse, print, printSchema } from 'graphql'

import { isProduction } from '.'
import { outputFile } from './filesystem'
import { Node, QueryManager } from './manager'

export interface QueryInfo {
  query?: string
  sha256Hash: string
}

const root = process.cwd()

export const persisted = 'persisted.graphql.json'
export const queryInfo = 'queryInfo.graphql.json'

export const publicPath = '/page-data/_graphql'

export const target = join(root, 'public', publicPath)

const queryCode = ({ name, value, sha256Hash }: QueryNode) => `
export const ${name} = {
  query: ${isProduction ? undefined : JSON.stringify(value)},
  sha256Hash: "${sha256Hash}",
  operationName: "${name}",
}
`

const wrapTypes = (types: string, node: QueryNode | null) => `
/**
 * Warning: This is an autogenerated file.
 *
 * Changes in this file won't take effect and will be overwritten
 */

// Base Types
${typeScriptPlugin.EXACT_SIGNATURE}
type Maybe<T> = T | null | undefined
type Scalars = {
  Boolean: boolean
  String: string
  Float: number
  Int: number
  ID: string
}

// Operation related types
${types}

// Query Related Code
${node ? queryCode(node) : ''}
`

type QueryNode = Node & { sha256Hash: string }
type FragmentNode = Node

const isQueryNode = (node: any): node is QueryNode =>
  typeof node.sha256Hash === 'string'

export class WebpackPlugin {
  public persistedPath: string
  public queryInfoPath: string

  constructor(public schema: GraphQLSchema) {
    this.persistedPath = join(root, 'public', publicPath, persisted)
    this.queryInfoPath = join(root, 'public', publicPath, queryInfo)

    mkdirSync(target, { recursive: true })
  }

  public optimizeQuery = (query: string) => {
    const document = parse(query)

    const optimized = optimizeDocuments(this.schema, [document], {
      includeFragments: false,
    })

    return print(optimized[0])
  }

  public generateCode = async (nodes: Array<QueryNode | FragmentNode>) => {
    return Promise.all(
      nodes.map(async (node) => {
        const { value, filename, ...rest } = node
        const types = await codegen({
          config: {
            preResolveTypes: true,
            avoidOptionals: true,
            enumsAsTypes: true,
            skipTypeNameForRoot: true,
            skipTypename: true,
          },
          documents: [{ document: parse(value) }],
          // used by a plugin internally, although the 'typescript' plugin currently
          // returns the string output, rather than writing to a file
          filename,
          schemaAst: this.schema,
          schema: parse(printSchema(this.schema)),
          // Plugins to use
          pluginMap: {
            typeScriptOperations: typeScriptOperationsPlugin,
          },
          // Plugins configurations
          plugins: [
            {
              typeScriptOperations: {},
            },
          ],
        })

        const queryNode = isQueryNode(node) ? node : null

        return {
          ...rest,
          value: wrapTypes(types, queryNode),
          filename,
        }
      })
    )
  }

  public apply(compiler: any) {
    compiler.hooks.done.tapPromise('gatsby-plugin-graphql', async () => {
      try {
        const manager = QueryManager.getSingleton()
        const allQueries = manager.getQueries()
        const allFragments = manager.getFragments()

        if (allQueries.length === 0) {
          return
        }

        // -------------------------------------
        // Optimize queries using Relay Compiler
        const optimizedQueries = allQueries.map(({ value, ...rest }) => ({
          value: this.optimizeQuery(value),
          ...rest,
        }))

        // -------------------------------------
        // Create Persisted Query Map
        const persistedQueryMap = optimizedQueries.reduce(
          (acc, { value, sha256Hash }) => {
            acc[sha256Hash] = value

            return acc
          },
          {} as Record<string, string>
        )

        await outputJson(this.persistedPath, persistedQueryMap)

        // -------------------------------------
        // Create Query Info to be used in the browser for making requests
        const queryInfoMap = optimizedQueries.reduce(
          (acc, { name, value, sha256Hash }) => {
            acc[name] = { query: value, sha256Hash }

            return acc
          },
          {} as Record<string, QueryInfo>
        )

        await outputJson(this.queryInfoPath, queryInfoMap)

        // -------------------------------------
        // Generate code using @graphql-codegen
        const codeNodes = await this.generateCode([
          ...optimizedQueries,
          ...allFragments,
        ])

        // write generated files
        await Promise.all(
          codeNodes.map(async ({ value, filename: filepath, name }) => {
            const filename = join(
              dirname(filepath),
              '__generated__',
              `${name}.graphql.ts`
            ).replace('src/pages', 'src') // Do not generate a folder inside src/pages otherwise gatsby's build breaks

            return outputFile(filename, value)
          })
        )
      } catch (err) {
        console.error('[gatsby-plugin-graphql]', err)
      }
    })
  }
}
